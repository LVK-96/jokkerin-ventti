import math
import re
import sys
import argparse
from pathlib import Path

import bpy
import mathutils

from fbx_tools import HIERARCHY, get_rust_enum_name, suppress_stdout_stderr

def main():
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]
    else:
        argv = []

    parser = argparse.ArgumentParser(description="Extract bone hierarchy from FBX to Rust.")
    parser.add_argument("input", help="Input FBX file")
    parser.add_argument("-o", "--output", required=True, help="Output Rust file")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose Blender output")
    args = parser.parse_args(argv)

    input_path = Path(args.input).resolve()
    output_path = Path(args.output).resolve()

    # Clear and import
    bpy.ops.wm.read_factory_settings(use_empty=True)
    try:
        with suppress_stdout_stderr(enabled=not args.verbose):
            # Supress blender noise
            bpy.ops.import_scene.fbx(filepath=str(input_path), use_manual_orientation=False)
    except RuntimeError as e:
        print(f"Error importing FBX: {e}")
        sys.exit(1)

    armature = None
    for obj in bpy.data.objects:
        if obj.type == 'ARMATURE':
            armature = obj
            break

    if not armature:
        print("No armature found in FBX")
        sys.exit(1)

    # Output content construction
    lines = []
    lines.append("// Generated by extract_hierarchy.py - DO NOT EDIT by hand!")
    lines.append("use glam::Vec3;")
    lines.append("")

    # Enum Definition
    lines.append("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]")
    lines.append("pub enum BoneId {")
    for name, _ in HIERARCHY:
        lines.append(f"    {get_rust_enum_name(name)},")
    lines.append("}")
    lines.append("")

    # BoneId Impl
    count = len(HIERARCHY)
    lines.append("impl BoneId {")
    lines.append(f"    pub const COUNT: usize = {count};")
    lines.append(f"    pub const ALL: [BoneId; {count}] = [")
    for name, _ in HIERARCHY:
        lines.append(f"        BoneId::{get_rust_enum_name(name)},")
    lines.append("    ];")
    lines.append("")
    lines.append("    pub const fn index(self) -> usize {")
    lines.append("        self as usize")
    lines.append("    }")
    lines.append("")
    lines.append("    pub const fn from_index(i: usize) -> Option<Self> {")
    lines.append(f"        if i < {count} {{")
    lines.append("            Some(Self::ALL[i])")
    lines.append("        } else {")
    lines.append("            None")
    lines.append("        }")
    lines.append("    }")
    lines.append("}")
    lines.append("")

    # Struct BoneDef
    lines.append("#[derive(Debug, Clone, Copy)]")
    lines.append("pub struct BoneDef {")
    lines.append("    pub parent: Option<BoneId>,")
    lines.append("    pub length: f32,")
    lines.append("    pub direction: Vec3,")
    lines.append("}")
    lines.append("")

    # Hierarchy Array
    lines.append("pub static BONE_HIERARCHY: [BoneDef; BoneId::COUNT] = [")

    for i, (name, parent_name) in enumerate(HIERARCHY):
        bone = armature.data.bones.get(name)
        if not bone:
            lines.append(f"    // ERROR: Bone {name} not found")
            lines.append(f"    BoneDef {{ parent: None, length: 0.0, direction: Vec3::Y }},")
            continue

        head_world = armature.matrix_world @ bone.head_local

        # Mapping: Blender Z-up -> Game Y-up
        # Game X = Blender X
        # Game Y = Blender Z (Height)
        # Game Z = -Blender Y (Depth)
        p1 = mathutils.Vector((head_world.x, head_world.z, -head_world.y))

        if parent_name:
            parent_bone = armature.data.bones.get(parent_name)
            p_head_world = armature.matrix_world @ parent_bone.head_local
            p0 = mathutils.Vector((p_head_world.x, p_head_world.z, -p_head_world.y))

            diff = p1 - p0
            length = diff.length
            if length > 0.0001:
                direction = diff.normalized()
            else:
                direction = mathutils.Vector((0, 1, 0)) # Fallback

            # Map parent enum
            parent_id = f"Some(BoneId::{get_rust_enum_name(parent_name)})"

            # Format Vec3
            dir_str = f"Vec3::new({direction.x:.3f}, {direction.y:.3f}, {direction.z:.3f})"
            if abs(direction.z - 1.0) < 0.01: dir_str = "Vec3::Z"
            if abs(direction.y - 1.0) < 0.01: dir_str = "Vec3::Y"
            if abs(direction.x - 1.0) < 0.01: dir_str = "Vec3::X"

            lines.append(f"    // {i}: {get_rust_enum_name(name)} (Parent: {get_rust_enum_name(parent_name)})")
            lines.append(f"    BoneDef {{ parent: {parent_id}, length: {length:.4f}, direction: {dir_str} }},")

        else:
            # Root (Pelvis)
            lines.append(f"    // {i}: {get_rust_enum_name(name)} (Root)")
            lines.append(f"    BoneDef {{ parent: None, length: 0.0, direction: Vec3::Y }},") # Root Y-up

    lines.append("];")

    with open(output_path, 'w') as f:
        f.write("\n".join(lines))
        f.write("\n")

    print(f"Success: {output_path}")

if __name__ == "__main__":
    main()
